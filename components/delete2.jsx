import { combineReducers } from "redux";
import { createStore } from "redux";
const BACKGROUND_POS_START = 50;
// these will be used as styles in our React component later
const defaultLogoState = {
    animationProgress: 0,
    backgroundPos: BACKGROUND_POS_START,
};
// Redux reducer
const logoReducer = function (state = defaultLogoState, action) {
    switch (action.type) {
        case "LOGO.SET_NEXT_ANIMATION_STEP":
            var progress = action.progress;
            // calculate the background position from
            // progress and BACKGROUND_POS_START
            return Object.assign({}, state, {
                animationProgress: progress,
                backgroundPos: Math.floor(
                    BACKGROUND_POS_START - progress * BACKGROUND_POS_START
                ),
            });
        default:
            return state;
    }
};
// Redux action
// We'll dispatch this on every frame to animate the element
const logoAnimationStep = function (progress) {
    return {
        type: "LOGO.SET_NEXT_ANIMATION_STEP",
        progress: progress,
    };
};
// Redux store
const storeApp = createStore(logoReducer, defaultLogoState);
// As our later code dispatches the logoAnimationStep action on the store with an increasing or decreasing progress value, we'll change the state of the store so that backgroundPos is somewhere between BACKGROUND_POS_START and 0. This is what will cause the logo to rise over time.
// Set up your React Elements
const Logo = React.createClass({
    render: function () {
        // this is where we use the state/props generated by the Redux
        // store to style our element
        let wrapperStyles = {
            transform: `translateY(${this.props.backgroundPos}px)`,
        };
        return (
            <div className="logo-wrapper absolute-center" style={wrapperStyles}>
                <a
                    className="logo-white absolute-center"
                    href={"http://www.instacart.com"}
                    target={"_blank"}
                ></a>
            </div>
        );
    },
});
// Main container component
const Container = React.createClass({
    getInitialState: function () {
        // set the intial state of your container component
        // to the state of the Redux store
        return storeApp.getState();
    },
    componentDidMount: function () {
        // subscribe to the Redux store's state changes
        this.unSubscribeStore = storeApp.subscribe(this.onChange);
    },
    componentWillUnmount: function () {
        this.unSubscribeStore();
    },
    onChange: function () {
        // set the state for container component every time
        // the Redux store's state changes
        this.setState(storeApp.getState());
    },
    render: function () {
        return (
            <div className="container-inner">
                <div className="main-content">
                    <Logo {...this.state} />
                </div>
            </div>
        );
    },
});
// Render final output
ReactDOM.render(React.createElement(Container), document.getElementById("container"));
// Now, we have the basics of our Redux app set up. Next, we'll create a function to change animationProgress over time to affect the value of backgroundPos, which we apply as a style to the Logo component. You should also grab the css from the fiddle if you'd like it to look nice.
// Creating the animation
// Next, create a new method, animateLogo, in the Container component that we'll call inside componentDidMount. This method will use the requestAnimationFrame method to ask the browser for a new frame. This ensures a smooth and performant animation.
const Container = React.createClass({
    componentDidMount: function () {
        this.animateLogo();
    },
    animateLogo: function () {
        // here we call animationStep on every frame using requestAnimationFrame
        // it dispatches the logoAnimationStep action on the store
        // with an increasing value, that should end at 0
        let duration = 1000; // in ms
        let fps = 60; // frames per second
        let scrollStep = 1 / ((duration / 1000) * fps);
        let takeStep = scrollStep;
        let idx = 1;
        let animationStep = function () {
            setTimeout(() => {
                if (this.state.animationProgress < 1) {
                    storeApp.dispatch(logoAnimationStep(takeStep));
                    idx += 1;
                    takeStep = scrollStep * idx;
                    window.requestAnimationFrame(animationStep.bind(this));
                }
            }, 1000 / fps);
        };
        window.requestAnimationFrame(animationStep.bind(this));
    },
});
// That's it! Most of this code is spent setting up a generic React component and Redux store. The interesting piece happens when we start to change the progress value over time, especially if you change it in reaction to user interaction like we do on the site.
// If you have any trouble, check out the working code of the simpler animation here.
// Looking Forward
// This can seem like a lot of work to just make something animate dynamically. I agree, though once the system is set up it's fairly easy to keep adding to it. That said, I hope to see some kind of animation framework that takes advantage of the tools we now have at our disposal â€” one that can integrate with an already created Redux store would be best.
// The browser still has a ways to go before it can reach the kind of rich, consistent feel we're seeing in native apps. But at least we now have the speed and tools to get there.
// If you're interested in this kind of work, be sure to check out our careers page!
